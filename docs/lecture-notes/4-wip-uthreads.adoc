= uthreads - User Mode Cooperative Threads

== Introduction

_uthreads_ is a small native library, developed in the AMD64 (x86-64) and C languages, for illustrating how multi-threading can be achieved in user mode.
Its is mainly intended as a pedagogical tool, providing a way for students to see an example of how some important concepts can be implemented, namely:

* What is a _context_ and what is _context switching_. 
* What is _scheduling_ and how it can be performed.
* What are the main thread states and how they are represented in the _uthread_ data structures.

== Development and execution environment

The _uthreads_ was designed for execution on a Linux environment using the AMD64 CPU architecture.
A way to have such an environment on non-Linux systes (e.g. Windows or macOS) is to use:

* Docker Desktop
* Visual Studio Code with the *Dev Containers* extension - https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers

The *Dev Containers* extensions allows Visual Studio Code to run in _client-server_ mode, where:

* Most of the Visual Studio Code components will run inside container.
* The Visual Studio Code user interface will still be running in the host system (e.g. Windows or macOS).

The configuration for this _client-server_ mode is defined inside the `.devcontainer` folder, namely:

* The `devcontainer.json` file.
* The `Dockerfile` file.

We will use the https://mcr.microsoft.com/en-us/product/devcontainers/cpp/about[mcr.microsoft.com/vscode/devcontainers/cpp:0-debian-11], which already include the tools required for C and C++ based application development.

== `uthreads` components

=== Lists

The `list.h` and `list.c` files define functions to create and operate over double-linked _intrusive_ lists, with _sentinel_ nodes.
An _intrusive_ double-linked list includes the next and previous pointers in the data structure itself, so that each list element only requires a single contiguous block of memory.

The `list_entry_t` structure contains the next and previous pointers. The data items managed by the list need to contain a field of this type.
Most of the functions are self-documenting (e.g. `list_init` initializes a list).

.An empty list.
[#img-empty-list]
image::imgs/empty-list.png[]

.List with two data items.
[#img-list-with-two-data-items]
image::imgs/list-with-two-data-items.png[]

The `node_of` is probably the least obvious part of this list. It returns the pointer to the data node, given the type of the data node and the pointer to the `list_entry_t` field inside the data node.

.`node_of` macro.
[#img-node-of]
image::imgs/node_of.png[]

=== Data structures

The `uthreads` library uses two main data structure types.
The first is `thread_t`, also called the thread descriptor, and contains information about a single thread, namely a pointer to the top of that thread's stack.

.Thread descriptor
[source, c]
----
// in uthread.c
struct uthread
{
  // needs to be the first field
  uint64_t rsp;
  start_routine_t start;
  uint64_t arg;
  list_entry_t list_entry;
};

// in uthread.h
typedef struct uthread uthread_t;
----

The second datata structure is `uthread_context_t` and defines the layout of the thread's saved context.

.Thread context
[source, c]
----
// in uthread.c
typedef struct uthread_context
{
  uint64_t r15;
  uint64_t r14;
  uint64_t r13;
  uint64_t r12;
  uint64_t rbx;
  uint64_t rbp;
  void (*func_addr)();
} uthread_context_t;
----

=== Global variables

The `uthreads` library uses the following global variables

* The `thread_running` pointing to the descriptor of the single _running_ thread. 
* The `queue_ready` with all the _ready_ threads.
* The `thread_main` pointing to the descriptor of the main thread.
